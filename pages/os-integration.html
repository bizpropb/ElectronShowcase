<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OS Integration - Electron Feature Explorer</title>

  <!-- CSS Files -->
  <link rel="stylesheet" href="../styles/theme.css">
  <link rel="stylesheet" href="../styles/animations.css">
  <link rel="stylesheet" href="../styles/main.css">
  <link rel="stylesheet" href="../styles/components.css">
</head>
<body>
  <div class="subcontainer">
    <!-- OS Integration Category -->
    <section class="category-section fade-in">
      <div class="category-header">
        <span class="category-icon">ðŸ’»</span>
        <h2 class="category-title">OS Integration</h2>
        <span class="category-count">3 features</span>
      </div>

      <div class="features-grid">
        <div class="card" id="clipboard-card" style="grid-column: span 2;">
          <div class="card-header">
            <span class="card-icon">ðŸ“‹</span>
            <h3 class="card-title">Clipboard Manager</h3>
          </div>
          <p class="card-description">
            Multi-format clipboard with text, HTML, RTF, images, history tracking, and monitoring.
          </p>

          <!-- Read/Write Operations -->
          <div class="clipboard-actions">
            <h4>Read & Write</h4>
            <div class="clipboard-input-container">
              <textarea id="clip-text" class="clipboard-textarea" placeholder="Enter text to copy..." style="padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); width: 100%; font-family: inherit; resize: vertical;"></textarea>
            </div>
            <div class="dialog-buttons">
              <button class="btn btn-success" id="clip-copy-text">Copy Text</button>
              <button class="btn btn-primary" id="clip-read-text">Read Text</button>
              <button class="btn btn-secondary" id="clip-read-all">Read All Formats</button>
              <button class="btn btn-warning" id="clip-clear">Clear Clipboard</button>
            </div>
          </div>

          <!-- Format Detection & Image Preview -->
          <div class="clipboard-actions">
            <h4>Format Detection & Preview</h4>
            <div class="dialog-buttons">
              <button class="btn btn-info" id="clip-detect-formats">Detect Formats</button>
              <button class="btn btn-success" id="clip-read-image">Read Image</button>
              <button class="btn btn-warning" id="clip-read-html">Read HTML</button>
            </div>
            <!-- Image Preview -->
            <div id="clip-image-preview" class="image-preview">
              <img id="clip-preview-img" class="preview-image">
            </div>
          </div>

          <!-- History & Monitoring -->
          <div class="clipboard-actions">
            <h4>History & Monitoring</h4>
            <div class="dialog-buttons">
              <button class="btn btn-secondary" id="clip-view-history">View History</button>
              <button class="btn btn-secondary" id="clip-clear-history">Clear History</button>
              <button class="btn btn-secondary" id="clip-monitor-toggle">
                <span id="clip-monitor-status">Start Monitoring</span>
              </button>
              <button class="btn btn-secondary" id="clip-get-stats">Get Stats</button>
            </div>
          </div>

          <!-- Result Display -->
          <div id="clip-result" class="result-display">
            <div class="result-display-title">Clipboard Result:</div>
            <div id="clip-result-content">Ready to manage clipboard...</div>
          </div>

          <span class="card-status ready">âœ“ Ready</span>
        </div>

        <div class="card" id="shell-card" style="grid-column: span 2;">
          <div class="card-header">
            <span class="card-icon">ðŸš€</span>
            <h3 class="card-title">Shell Integration & Protocol Handler</h3>
          </div>
          <p class="card-description">
            Open URLs in browser, reveal files in explorer, move to trash, play beeps, and handle custom protocol URLs.
          </p>

          <!-- URL Operations -->
          <div class="shell-actions">
            <h4>Open External URLs</h4>
            <div class="shell-url-container">
              <input type="text" id="shell-url" class="shell-url-input" placeholder="https://example.com" value="https://www.electronjs.org" style="padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary);">
              <button class="btn btn-primary" id="shell-open-url">Open in Browser</button>
            </div>
          </div>

          <!-- File Operations -->
          <div style="margin-top: var(--space-4);">
            <h4 style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">File Operations</h4>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--space-2); margin-bottom: var(--space-2);">
              <button class="btn" id="shell-select-file" style="background: var(--bg-tertiary);">Select File</button>
              <button class="btn btn-primary" id="shell-open-file">Open with Default App</button>
              <button class="btn" id="shell-show-in-folder" style="background: var(--accent-blue);">Show in Folder</button>
              <button class="btn btn-warning" id="shell-move-to-trash">Move to Trash</button>
            </div>
            <div id="shell-selected-file" style="font-size: var(--font-size-xs); color: var(--text-secondary); padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">
              No file selected (click "Select File" to choose one)
            </div>
          </div>

          <!-- System Sounds & Protocol -->
          <div style="margin-top: var(--space-4);">
            <h4 style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">System Sounds & Protocol Handler</h4>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: var(--space-2);">
              <button class="btn" id="shell-beep" style="background: var(--accent-green);">ðŸ”” Play System Beep</button>
              <button class="btn" id="shell-test-protocol" style="background: var(--accent-blue);">ðŸ”— Test Protocol Handler</button>
            </div>
          </div>

          <!-- Protocol URL Examples -->
          <div style="margin-top: var(--space-4);">
            <h4 style="font-size: var(--font-size-sm); color: var(--text-secondary); margin-bottom: var(--space-2);">Custom Protocol (electronshowcase://)</h4>
            <div style="font-size: var(--font-size-xs); color: var(--text-secondary); padding: var(--space-3); background: var(--bg-tertiary); border-radius: 6px;">
              <div style="margin-bottom: 8px;"><strong>Example URLs:</strong></div>
              <div style="font-family: monospace; margin-bottom: 4px;">â€¢ electronshowcase://feature/notifications</div>
              <div style="font-family: monospace; margin-bottom: 4px;">â€¢ electronshowcase://action/screenshot</div>
              <div style="font-family: monospace;">â€¢ electronshowcase://open?file=/path/to/file</div>
              <div style="margin-top: 8px; color: var(--text-primary);">Click "Test Protocol Handler" to try it! The app will handle the URL even if closed.</div>
            </div>
          </div>

          <!-- Result Display -->
          <div id="shell-result" style="margin-top: var(--space-3); padding: var(--space-3); background: var(--bg-tertiary); border-radius: 6px; font-size: var(--font-size-xs); color: var(--text-secondary); min-height: 60px;">
            <div style="color: var(--text-primary); margin-bottom: var(--space-2);">Shell Result:</div>
            <div id="shell-result-content">Ready to interact with system shell...</div>
          </div>

          <span class="card-status ready">âœ“ Ready</span>
        </div>

        <div class="card">
          <div class="card-header">
            <span class="card-icon">ðŸ”‹</span>
            <h3 class="card-title">Power Management</h3>
          </div>
          <p class="card-description">
            Monitor battery status, suspend/resume events, and idle detection.
          </p>
          <span class="card-status coming-soon">Coming Soon</span>
        </div>
      </div>
    </section>

  </div>

  <script>
    /**
     * Notification System Setup
     */
    function setupNotificationSystem() {
      const api = window.electronAPI;
      if (!api) return;

      // Helper function to log events
      function logEvent(message) {
        const logContent = document.getElementById('notification-log-content');
        if (logContent) {
          const timestamp = new Date().toLocaleTimeString();
          const entry = document.createElement('div');
          entry.textContent = `[${timestamp}] ${message}`;
          entry.style.marginBottom = '4px';
          logContent.appendChild(entry);
          logContent.scrollTop = logContent.scrollHeight;

          // Limit log entries to last 20
          while (logContent.children.length > 20) {
            logContent.removeChild(logContent.firstChild);
          }
        }
      }

      // Helper function to update stats
      async function updateStats() {
        try {
          const stats = await api.getNotificationStats();
          document.getElementById('stats-total').textContent = stats.totalShown;
          document.getElementById('stats-history').textContent = stats.historyCount;
          document.getElementById('stats-queued').textContent = stats.queuedCount;
          document.getElementById('stats-active').textContent = stats.activeCount;

          // Update DND status display
          const dndStatus = document.getElementById('dnd-status');
          if (dndStatus) {
            dndStatus.textContent = stats.doNotDisturb ? 'DND: On ðŸ”•' : 'DND: Off ðŸ””';
            document.getElementById('notify-dnd-toggle').style.background =
              stats.doNotDisturb ? 'var(--accent-red)' : 'var(--bg-tertiary)';
          }
        } catch (error) {
          console.error('Error updating stats:', error);
        }
      }

      // Basic notification buttons
      document.getElementById('notify-info')?.addEventListener('click', async () => {
        const result = await api.showNotificationTyped('info', 'Information',
          'This is an info notification from Electron Feature Explorer!');
        logEvent(`Info notification shown (ID: ${result.id})`);
        await updateStats();
      });

      document.getElementById('notify-success')?.addEventListener('click', async () => {
        const result = await api.showNotificationTyped('success', 'Success! ðŸŽ‰',
          'Your action completed successfully. Click to focus the app.');
        logEvent(`Success notification shown (ID: ${result.id})`);
        await updateStats();
      });

      document.getElementById('notify-warning')?.addEventListener('click', async () => {
        const result = await api.showNotificationTyped('warning', 'Warning',
          'This is a warning notification. Please pay attention!');
        logEvent(`Warning notification shown (ID: ${result.id})`);
        await updateStats();
      });

      document.getElementById('notify-error')?.addEventListener('click', async () => {
        const result = await api.showNotificationTyped('error', 'Error',
          'An error occurred! This is a critical notification.');
        logEvent(`Error notification shown (ID: ${result.id})`);
        await updateStats();
      });

      // Advanced notification buttons
      document.getElementById('notify-with-actions')?.addEventListener('click', async () => {
        const result = await api.showNotification({
          title: 'Notification with Actions',
          body: 'This notification has action buttons. Try clicking them!',
          actions: [
            { type: 'button', text: 'Accept' },
            { type: 'button', text: 'Decline' }
          ]
        });
        logEvent(`Notification with actions shown (ID: ${result.id})`);
        await updateStats();
      });

      document.getElementById('notify-with-reply')?.addEventListener('click', async () => {
        const result = await api.showNotification({
          title: 'Quick Reply',
          body: 'You can reply directly to this notification!',
          hasReply: true,
          replyPlaceholder: 'Type your reply here...'
        });
        logEvent(`Notification with reply shown (ID: ${result.id})`);
        await updateStats();
      });

      document.getElementById('notify-silent')?.addEventListener('click', async () => {
        const result = await api.showNotification({
          title: 'Silent Notification',
          body: 'This notification is silent (no sound).',
          silent: true
        });
        logEvent(`Silent notification shown (ID: ${result.id})`);
        await updateStats();
      });

      // Do Not Disturb toggle
      document.getElementById('notify-dnd-toggle')?.addEventListener('click', async () => {
        const result = await api.toggleDND();
        logEvent(`Do Not Disturb ${result.enabled ? 'enabled' : 'disabled'}`);
        await updateStats();
      });

      // View history
      document.getElementById('notify-show-history')?.addEventListener('click', async () => {
        const history = await api.getNotificationHistory(10);
        logEvent(`History: ${history.length} notifications`);
        if (history.length > 0) {
          console.log('Notification History:', history);
          alert(`Last ${history.length} notifications:\n\n` +
            history.slice(0, 5).map((n, i) => `${i + 1}. ${n.title}: ${n.body}`).join('\n') +
            (history.length > 5 ? '\n\n...and more (see console)' : ''));
        } else {
          alert('No notification history yet.');
        }
      });

      // View queue
      document.getElementById('notify-show-queue')?.addEventListener('click', async () => {
        const queue = await api.getNotificationQueue();
        logEvent(`Queue: ${queue.length} notifications`);
        if (queue.length > 0) {
          console.log('Notification Queue:', queue);
          alert(`${queue.length} notifications in queue:\n\n` +
            queue.map((n, i) => `${i + 1}. ${n.title}: ${n.body}`).join('\n'));
        } else {
          alert('No notifications in queue.');
        }
      });

      // Close all notifications
      document.getElementById('notify-close-all')?.addEventListener('click', async () => {
        const result = await api.closeAllNotifications();
        logEvent(`Closed ${result.count} active notification(s)`);
        await updateStats();
      });

      // Listen for notification events
      api.on('notification:reply-received', (data) => {
        logEvent(`Reply received: "${data.reply}"`);
        console.log('Notification reply:', data);
      });

      api.on('notification:action-clicked', (data) => {
        logEvent(`Action clicked: ${data.action.text}`);
        console.log('Notification action:', data);
      });

      // Initial stats update
      updateStats();

      // Update stats periodically
      setInterval(updateStats, 5000);
    }

    // Verify that electronAPI is available and populate version info
    if (window.electronAPI) {
      console.log('âœ“ Electron API is available');
      console.log('Platform:', window.electronAPI.platform);
      console.log('Versions:', window.electronAPI.versions);

      // Display platform and version info (only if elements exist)
      const platformEl = document.getElementById('platform');
      const nodeVersionEl = document.getElementById('node-version');
      const chromeVersionEl = document.getElementById('chrome-version');
      const electronVersionEl = document.getElementById('electron-version');

      if (platformEl) platformEl.textContent = window.electronAPI.platform;
      if (nodeVersionEl) nodeVersionEl.textContent = window.electronAPI.versions.node;
      if (chromeVersionEl) chromeVersionEl.textContent = window.electronAPI.versions.chrome;
      if (electronVersionEl) electronVersionEl.textContent = window.electronAPI.versions.electron;
    } else {
      console.error('âœ— Electron API is NOT available - check preload.js');
    }

    /**
     * Window Management System Setup
     */
    function setupWindowManagement() {
      const api = window.electronAPI;
      if (!api) return;

      // Show About Window
      const showAboutBtn = document.getElementById('show-about-btn');
      if (showAboutBtn) {
        showAboutBtn.addEventListener('click', async () => {
          const result = await api.windowShowAbout();
          console.log('Show about result:', result);
        });
      }

      // Show Settings Window
      const showSettingsBtn = document.getElementById('show-settings-btn');
      if (showSettingsBtn) {
        showSettingsBtn.addEventListener('click', async () => {
          const result = await api.windowShowSettings();
          console.log('Show settings result:', result);
        });
      }

      // Create Floating Note
      const createFloatingNoteBtn = document.getElementById('create-floating-note-btn');
      if (createFloatingNoteBtn) {
        createFloatingNoteBtn.addEventListener('click', async () => {
          const result = await api.windowCreateFloatingNote();
          console.log('Create floating note result:', result);
          if (result.success) {
            await api.showNotificationTyped('success', 'Window Created', 'Floating note window created!');
          }
        });
      }

      // Create Overlay Window
      const createOverlayBtn = document.getElementById('create-overlay-btn');
      if (createOverlayBtn) {
        createOverlayBtn.addEventListener('click', async () => {
          const result = await api.windowCreateOverlay({
            message: 'This is a transparent overlay window!'
          });
          console.log('Create overlay result:', result);
          if (result.success) {
            await api.showNotificationTyped('success', 'Window Created', 'Overlay window created! It will auto-close in 5 seconds.');
          }
        });
      }

      // List Windows
      const listWindowsBtn = document.getElementById('list-windows-btn');
      const windowsList = document.getElementById('windows-list');
      if (listWindowsBtn && windowsList) {
        listWindowsBtn.addEventListener('click', async () => {
          const result = await api.windowGetAll();
          console.log('Get all windows result:', result);

          if (result.success && result.windows) {
            if (result.windows.length === 0) {
              windowsList.innerHTML = '<p style="color: var(--text-tertiary);">No windows found</p>';
            } else {
              let html = '<div style="margin-top: 8px;">';
              html += '<p style="font-weight: 600; margin-bottom: 8px;">Open Windows:</p>';
              result.windows.forEach(win => {
                html += `
                  <div style="padding: 8px; background: var(--bg-tertiary); border-radius: 4px; margin-bottom: 4px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span>
                        <strong>${win.type}</strong>
                        ${win.title ? `- ${win.title}` : ''}
                      </span>
                      <span style="color: var(--text-tertiary); font-size: 0.875rem;">
                        ${win.bounds.width}x${win.bounds.height}
                      </span>
                    </div>
                  </div>
                `;
              });
              html += '</div>';
              windowsList.innerHTML = html;
            }
          } else {
            windowsList.innerHTML = '<p style="color: var(--accent-red);">Failed to get windows</p>';
          }
        });
      }
    }

    // Add staggered animation delays to cards
    // Run immediately since DOMContentLoaded won't fire when loaded via innerHTML
    (function initPage() {
      const cards = document.querySelectorAll('.card');
      cards.forEach((card, index) => {
        card.style.animationDelay = `${index * 0.05}s`;
        card.classList.add('fade-in');
      });

      // Notification System Handlers
      setupNotificationSystem();

      // Window Management Handlers
      setupWindowManagement();

      // File Dialog handlers
      const resultContent = document.getElementById('dialog-result-content');
      let lastSelectedFile = null;

      function setResult(text, isError = false) {
        resultContent.innerHTML = text;
        resultContent.style.color = isError ? 'var(--accent-red)' : 'var(--text-secondary)';
      }

      const dialogOpenBtn = document.getElementById('dialog-open');
      if (dialogOpenBtn && window.electronAPI?.openFileDialog) {
        dialogOpenBtn.addEventListener('click', async () => {
          const result = await window.electronAPI.openFileDialog({
            title: 'Select a file to open',
            filters: [
              { name: 'Text Files', extensions: ['txt', 'md', 'json'] },
              { name: 'Images', extensions: ['png', 'jpg', 'jpeg', 'gif'] },
              { name: 'All Files', extensions: ['*'] }
            ]
          });
          if (!result.canceled && result.filePaths.length > 0) {
            lastSelectedFile = result.filePaths[0];
            setResult(`âœ“ Selected: <strong>${result.filePaths[0]}</strong>`);
          } else {
            setResult('Dialog canceled');
          }
          console.log('Open file result:', result);
        });
      }

      const dialogSaveBtn = document.getElementById('dialog-save');
      if (dialogSaveBtn && window.electronAPI?.saveFileDialog) {
        dialogSaveBtn.addEventListener('click', async () => {
          const result = await window.electronAPI.saveFileDialog({
            title: 'Save file as',
            defaultPath: 'my-document.txt',
            filters: [
              { name: 'Text Files', extensions: ['txt'] },
              { name: 'Markdown', extensions: ['md'] },
              { name: 'All Files', extensions: ['*'] }
            ]
          });
          if (!result.canceled && result.filePath) {
            setResult(`âœ“ Save location: <strong>${result.filePath}</strong>`);
            // Demo: Write some content
            await window.electronAPI.writeFile(result.filePath, `Sample content created at ${new Date().toLocaleString()}`);
            setResult(`âœ“ File saved: <strong>${result.filePath}</strong>`);
          } else {
            setResult('Dialog canceled');
          }
          console.log('Save file result:', result);
        });
      }

      const dialogDirBtn = document.getElementById('dialog-directory');
      if (dialogDirBtn && window.electronAPI?.selectDirectoryDialog) {
        dialogDirBtn.addEventListener('click', async () => {
          const result = await window.electronAPI.selectDirectoryDialog({
            title: 'Select a directory'
          });
          if (!result.canceled && result.filePaths.length > 0) {
            setResult(`âœ“ Directory: <strong>${result.filePaths[0]}</strong>`);
          } else {
            setResult('Dialog canceled');
          }
          console.log('Select directory result:', result);
        });
      }

      const dialogMultipleBtn = document.getElementById('dialog-multiple');
      if (dialogMultipleBtn && window.electronAPI?.openFilesDialog) {
        dialogMultipleBtn.addEventListener('click', async () => {
          const result = await window.electronAPI.openFilesDialog({
            title: 'Select multiple files',
            filters: [
              { name: 'All Files', extensions: ['*'] }
            ]
          });
          if (!result.canceled && result.filePaths.length > 0) {
            setResult(`âœ“ Selected <strong>${result.filePaths.length}</strong> file(s):<br>` +
              result.filePaths.map(f => `â€¢ ${f}`).slice(0, 5).join('<br>') +
              (result.filePaths.length > 5 ? '<br>...and more' : ''));
          } else {
            setResult('Dialog canceled');
          }
          console.log('Open multiple files result:', result);
        });
      }

      // Message Box handlers
      document.getElementById('msgbox-info')?.addEventListener('click', async () => {
        const result = await window.electronAPI.showMessageBox({
          type: 'info',
          title: 'Information',
          message: 'This is an informational message box',
          detail: 'You can display important information to users using this dialog.',
          buttons: ['Got it', 'Cancel']
        });
        setResult(`Info box - Button clicked: ${result.response === 0 ? 'Got it' : 'Cancel'}`);
      });

      document.getElementById('msgbox-warning')?.addEventListener('click', async () => {
        const result = await window.electronAPI.showMessageBox({
          type: 'warning',
          title: 'Warning',
          message: 'This is a warning message',
          detail: 'Are you sure you want to proceed with this action?',
          buttons: ['Proceed', 'Cancel'],
          defaultId: 1
        });
        setResult(`Warning box - Button clicked: ${result.response === 0 ? 'Proceed' : 'Cancel'}`);
      });

      document.getElementById('msgbox-error')?.addEventListener('click', async () => {
        const result = await window.electronAPI.showMessageBox({
          type: 'error',
          title: 'Error',
          message: 'An error has occurred',
          detail: 'The operation could not be completed. Please try again.',
          buttons: ['Retry', 'Ignore', 'Cancel'],
          defaultId: 2
        });
        const buttonText = ['Retry', 'Ignore', 'Cancel'][result.response];
        setResult(`Error box - Button clicked: ${buttonText}`);
      });

      document.getElementById('msgbox-question')?.addEventListener('click', async () => {
        const result = await window.electronAPI.showMessageBox({
          type: 'question',
          title: 'Question',
          message: 'Do you want to save your changes?',
          detail: 'Your changes will be lost if you don\'t save them.',
          buttons: ['Save', 'Don\'t Save', 'Cancel'],
          defaultId: 0
        });
        const buttonText = ['Save', 'Don\'t Save', 'Cancel'][result.response];
        setResult(`Question box - Button clicked: ${buttonText}`);
      });

      // File Operations handlers
      document.getElementById('file-read-preview')?.addEventListener('click', async () => {
        if (!lastSelectedFile) {
          setResult('âš  Please select a file first using "Open File" button', true);
          return;
        }

        const result = await window.electronAPI.readFile(lastSelectedFile);
        if (result.success) {
          const preview = result.content.substring(0, 200) + (result.content.length > 200 ? '...' : '');
          setResult(`âœ“ Read file: <strong>${result.metadata.name}</strong><br>` +
            `Size: ${(result.metadata.size / 1024).toFixed(2)} KB<br>` +
            `Preview: <div style="margin-top: 8px; padding: 8px; background: var(--bg-primary); border-radius: 4px; font-family: monospace; font-size: 11px; white-space: pre-wrap;">${preview}</div>`);
        } else {
          setResult(`âœ— Error reading file: ${result.error}`, true);
        }
      });

      document.getElementById('file-metadata')?.addEventListener('click', async () => {
        if (!lastSelectedFile) {
          setResult('âš  Please select a file first using "Open File" button', true);
          return;
        }

        const result = await window.electronAPI.getFileMetadata(lastSelectedFile);
        if (result.success) {
          const m = result.metadata;
          setResult(`<strong>File Metadata:</strong><br>` +
            `Name: ${m.name}<br>` +
            `Size: ${(m.size / 1024).toFixed(2)} KB<br>` +
            `Extension: ${m.extension || 'none'}<br>` +
            `Type: ${m.isFile ? 'File' : 'Directory'}<br>` +
            `Created: ${new Date(m.created).toLocaleString()}<br>` +
            `Modified: ${new Date(m.modified).toLocaleString()}`);
        } else {
          setResult(`âœ— Error getting metadata: ${result.error}`, true);
        }
      });

      document.getElementById('file-recent')?.addEventListener('click', async () => {
        const result = await window.electronAPI.getRecentFiles();
        if (result.recentFiles.length > 0) {
          setResult(`<strong>Recent Files (${result.recentFiles.length}):</strong><br>` +
            result.recentFiles.map((f, i) => `${i + 1}. ${f}`).join('<br>'));
        } else {
          setResult('No recent files yet. Open a file to add it to the list.');
        }
      });

      // Drag and Drop handlers
      const dropZone = document.getElementById('drop-zone');
      const droppedFilesDiv = document.getElementById('dropped-files');

      if (dropZone) {
        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          dropZone.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
          });
        });

        // Visual feedback on drag
        ['dragenter', 'dragover'].forEach(eventName => {
          dropZone.addEventListener(eventName, () => {
            dropZone.style.borderColor = 'var(--accent-blue)';
            dropZone.style.background = 'var(--bg-secondary)';
          });
        });

        ['dragleave', 'drop'].forEach(eventName => {
          dropZone.addEventListener(eventName, () => {
            dropZone.style.borderColor = 'var(--border)';
            dropZone.style.background = 'var(--bg-tertiary)';
          });
        });

        // Handle drop
        dropZone.addEventListener('drop', async (e) => {
          const files = Array.from(e.dataTransfer.files);

          if (files.length > 0) {
            droppedFilesDiv.innerHTML = `<div style="color: var(--text-primary); margin-bottom: 8px;"><strong>Dropped ${files.length} file(s):</strong></div>`;

            for (const file of files) {
              const fileInfo = document.createElement('div');
              fileInfo.style.marginBottom = '4px';
              fileInfo.style.padding = '4px 8px';
              fileInfo.style.background = 'var(--bg-primary)';
              fileInfo.style.borderRadius = '4px';
              fileInfo.innerHTML = `ðŸ“„ ${file.name} (${(file.size / 1024).toFixed(2)} KB) - ${file.type || 'unknown type'}`;
              droppedFilesDiv.appendChild(fileInfo);

              // Set as last selected file
              lastSelectedFile = file.path;
            }
          }
        });

        // Click to open file dialog
        dropZone.addEventListener('click', async () => {
          const result = await window.electronAPI.openFilesDialog({
            title: 'Select files'
          });

          if (!result.canceled && result.filePaths.length > 0) {
            droppedFilesDiv.innerHTML = `<div style="color: var(--text-primary); margin-bottom: 8px;"><strong>Selected ${result.filePaths.length} file(s):</strong></div>`;

            for (const filePath of result.filePaths) {
              const metadata = await window.electronAPI.getFileMetadata(filePath);
              if (metadata.success) {
                const fileInfo = document.createElement('div');
                fileInfo.style.marginBottom = '4px';
                fileInfo.style.padding = '4px 8px';
                fileInfo.style.background = 'var(--bg-primary)';
                fileInfo.style.borderRadius = '4px';
                fileInfo.innerHTML = `ðŸ“„ ${metadata.metadata.name} (${(metadata.metadata.size / 1024).toFixed(2)} KB)`;
                droppedFilesDiv.appendChild(fileInfo);

                lastSelectedFile = filePath;
              }
            }
          }
        });
      }

      // Persistent Storage handlers
      const storeResultContent = document.getElementById('store-result-content');

      function setStoreResult(text, isError = false) {
        storeResultContent.innerHTML = text;
        storeResultContent.style.color = isError ? 'var(--accent-red)' : 'var(--text-secondary)';
      }

      async function updateStoreStats() {
        const result = await window.electronAPI.storeGetStats();
        if (result.success) {
          const keysEl = document.getElementById('stats-keys');
          const sizeEl = document.getElementById('stats-size');
          const secretsEl = document.getElementById('stats-secrets');
          const pathEl = document.getElementById('stats-path');

          if (keysEl) keysEl.textContent = result.stats.keys;
          if (sizeEl) sizeEl.textContent = result.stats.size;
          if (secretsEl) secretsEl.textContent = result.stats.secretsCount;
          if (pathEl) pathEl.textContent = result.stats.path;
        }
      }

      // Basic CRUD operations
      document.getElementById('store-set')?.addEventListener('click', async () => {
        const key = document.getElementById('store-key').value;
        const value = document.getElementById('store-value').value;

        if (!key) {
          setStoreResult('âš  Please enter a key', true);
          return;
        }

        // Try to parse value as JSON if it looks like JSON
        let parsedValue = value;
        if (value.startsWith('{') || value.startsWith('[')) {
          try {
            parsedValue = JSON.parse(value);
          } catch (e) {
            // Keep as string if not valid JSON
          }
        }

        const result = await window.electronAPI.storeSet(key, parsedValue);
        if (result.success) {
          setStoreResult(`âœ“ Set <strong>${key}</strong> = ${JSON.stringify(parsedValue)}`);
          await updateStoreStats();
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      document.getElementById('store-get')?.addEventListener('click', async () => {
        const key = document.getElementById('store-key').value;

        if (!key) {
          setStoreResult('âš  Please enter a key', true);
          return;
        }

        const result = await window.electronAPI.storeGet(key);
        if (result.success) {
          if (result.value !== undefined) {
            setStoreResult(`âœ“ <strong>${key}</strong> = <div style="margin-top: 8px; padding: 8px; background: var(--bg-primary); border-radius: 4px; font-family: monospace;">${JSON.stringify(result.value, null, 2)}</div>`);
          } else {
            setStoreResult(`âš  Key <strong>${key}</strong> does not exist`);
          }
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      document.getElementById('store-delete')?.addEventListener('click', async () => {
        const key = document.getElementById('store-key').value;

        if (!key) {
          setStoreResult('âš  Please enter a key', true);
          return;
        }

        const result = await window.electronAPI.storeDelete(key);
        if (result.success) {
          setStoreResult(`âœ“ Deleted key: <strong>${key}</strong>`);
          await updateStoreStats();
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      document.getElementById('store-has')?.addEventListener('click', async () => {
        const key = document.getElementById('store-key').value;

        if (!key) {
          setStoreResult('âš  Please enter a key', true);
          return;
        }

        const result = await window.electronAPI.storeHas(key);
        if (result.success) {
          setStoreResult(`Key <strong>${key}</strong> ${result.exists ? 'âœ“ exists' : 'âœ— does not exist'}`);
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Encrypted secrets operations
      document.getElementById('secret-set')?.addEventListener('click', async () => {
        const key = document.getElementById('secret-key').value;
        const value = document.getElementById('secret-value').value;

        if (!key || !value) {
          setStoreResult('âš  Please enter both key and value', true);
          return;
        }

        const result = await window.electronAPI.storeSetSecret(key, value);
        if (result.success) {
          setStoreResult(`âœ“ Encrypted and stored secret: <strong>${key}</strong> ðŸ”’`);
          document.getElementById('secret-value').value = ''; // Clear password field
          await updateStoreStats();
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      document.getElementById('secret-get')?.addEventListener('click', async () => {
        const key = document.getElementById('secret-key').value;

        if (!key) {
          setStoreResult('âš  Please enter a secret key', true);
          return;
        }

        const result = await window.electronAPI.storeGetSecret(key);
        if (result.success && result.value) {
          setStoreResult(`âœ“ Decrypted secret <strong>${key}</strong>: <div style="margin-top: 8px; padding: 8px; background: var(--bg-primary); border-radius: 4px; font-family: monospace;">${result.value}</div>`);
        } else if (result.success && !result.value) {
          setStoreResult(`âš  Secret <strong>${key}</strong> does not exist`);
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      document.getElementById('secret-delete')?.addEventListener('click', async () => {
        const key = document.getElementById('secret-key').value;

        if (!key) {
          setStoreResult('âš  Please enter a secret key', true);
          return;
        }

        const result = await window.electronAPI.storeDeleteSecret(key);
        if (result.success) {
          setStoreResult(`âœ“ Deleted secret: <strong>${key}</strong>`);
          await updateStoreStats();
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Management operations
      document.getElementById('store-view-all')?.addEventListener('click', async () => {
        const result = await window.electronAPI.storeGetAll();
        if (result.success) {
          const data = result.data;
          const keys = Object.keys(data);
          if (keys.length > 0) {
            setStoreResult(`<strong>All Data (${keys.length} keys):</strong><div style="margin-top: 8px; padding: 8px; background: var(--bg-primary); border-radius: 4px; font-family: monospace; white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${JSON.stringify(data, null, 2)}</div>`);
          } else {
            setStoreResult('Store is empty');
          }
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      document.getElementById('store-export')?.addEventListener('click', async () => {
        const includeSecrets = confirm('Include encrypted secrets in export?');
        const result = await window.electronAPI.storeExport(includeSecrets);

        if (result.success) {
          // Save to file
          const saveResult = await window.electronAPI.saveFileDialog({
            title: 'Export Store Data',
            defaultPath: `store-export-${Date.now()}.json`,
            filters: [{ name: 'JSON Files', extensions: ['json'] }]
          });

          if (!saveResult.canceled && saveResult.filePath) {
            await window.electronAPI.writeFile(saveResult.filePath, result.data);
            setStoreResult(`âœ“ Exported to: <strong>${saveResult.filePath}</strong>`);
          } else {
            setStoreResult('Export canceled');
          }
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      document.getElementById('store-import')?.addEventListener('click', async () => {
        const fileResult = await window.electronAPI.openFileDialog({
          title: 'Import Store Data',
          filters: [{ name: 'JSON Files', extensions: ['json'] }]
        });

        if (!fileResult.canceled && fileResult.filePaths.length > 0) {
          const readResult = await window.electronAPI.readFile(fileResult.filePaths[0]);

          if (readResult.success) {
            const merge = confirm('Merge with existing data? (Cancel = replace all)');
            const importResult = await window.electronAPI.storeImport(readResult.content, merge);

            if (importResult.success) {
              setStoreResult(`âœ“ Imported data from: <strong>${fileResult.filePaths[0]}</strong> (${merge ? 'merged' : 'replaced'})`);
              await updateStoreStats();
            } else {
              setStoreResult(`âœ— Error importing: ${importResult.error}`, true);
            }
          } else {
            setStoreResult(`âœ— Error reading file: ${readResult.error}`, true);
          }
        } else {
          setStoreResult('Import canceled');
        }
      });

      document.getElementById('store-reset')?.addEventListener('click', async () => {
        if (!confirm('Reset all data to defaults? This cannot be undone!')) {
          return;
        }

        const result = await window.electronAPI.storeReset();
        if (result.success) {
          setStoreResult('âœ“ Store reset to defaults');
          await updateStoreStats();
        } else {
          setStoreResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Initial stats update
      updateStoreStats();

      // Update stats periodically
      setInterval(updateStoreStats, 5000);

      // Clipboard handlers
      const clipResultContent = document.getElementById('clip-result-content');
      const clipTextArea = document.getElementById('clip-text');
      const clipImagePreview = document.getElementById('clip-image-preview');
      const clipPreviewImg = document.getElementById('clip-preview-img');
      let clipMonitoring = false;

      function setClipResult(text, isError = false) {
        clipResultContent.innerHTML = text;
        clipResultContent.style.color = isError ? 'var(--accent-red)' : 'var(--text-secondary)';
      }

      // Copy text to clipboard
      document.getElementById('clip-copy-text')?.addEventListener('click', async () => {
        const text = clipTextArea.value;
        if (!text) {
          setClipResult('âš  Please enter text to copy', true);
          return;
        }

        const result = await window.electronAPI.clipboardWriteText(text);
        if (result.success) {
          setClipResult(`âœ“ Copied to clipboard: <strong>${text.length}</strong> characters`);
        } else {
          setClipResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Read text from clipboard
      document.getElementById('clip-read-text')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardReadText();
        if (result.success) {
          clipTextArea.value = result.text;
          setClipResult(`âœ“ Read <strong>${result.text.length}</strong> characters from clipboard`);
        } else {
          setClipResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Read all formats
      document.getElementById('clip-read-all')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardReadAll();
        if (result.success) {
          const data = result.data;
          let output = `<strong>Available Formats:</strong> ${data.formats.join(', ')}<br><br>`;

          if (data.content.text) {
            output += `<strong>Text:</strong> ${data.content.text.substring(0, 100)}${data.content.text.length > 100 ? '...' : ''}<br>`;
          }
          if (data.content.html) {
            output += `<strong>HTML:</strong> ${data.content.html.substring(0, 100)}...<br>`;
          }
          if (data.content.image) {
            output += `<strong>Image:</strong> ${data.content.image.size.width}x${data.content.image.size.height}<br>`;
          }

          setClipResult(output);
        } else {
          setClipResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Clear clipboard
      document.getElementById('clip-clear')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardClear();
        if (result.success) {
          setClipResult('âœ“ Clipboard cleared');
        } else {
          setClipResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Detect formats
      document.getElementById('clip-detect-formats')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardAvailableFormats();
        if (result.success) {
          const hasText = await window.electronAPI.clipboardHas('text');
          const hasImage = await window.electronAPI.clipboardHas('image');
          const hasHTML = await window.electronAPI.clipboardHas('html');

          setClipResult(`<strong>Detected Formats:</strong><br>` +
            `${result.formats.join(', ')}<br><br>` +
            `Text: ${hasText.has ? 'âœ“' : 'âœ—'} | ` +
            `HTML: ${hasHTML.has ? 'âœ“' : 'âœ—'} | ` +
            `Image: ${hasImage.has ? 'âœ“' : 'âœ—'}`);
        } else {
          setClipResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Read image
      document.getElementById('clip-read-image')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardReadImage();
        if (result.success && result.image) {
          clipPreviewImg.src = result.image.dataURL;
          clipImagePreview.style.display = 'block';
          setClipResult(`âœ“ Image loaded: <strong>${result.image.size.width}x${result.image.size.height}</strong>`);
        } else if (result.success && !result.image) {
          clipImagePreview.style.display = 'none';
          setClipResult('âš  No image in clipboard');
        } else {
          setClipResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Read HTML
      document.getElementById('clip-read-html')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardReadHTML();
        if (result.success && result.html) {
          setClipResult(`<strong>HTML Content:</strong><div style="margin-top: 8px; padding: 8px; background: var(--bg-primary); border-radius: 4px; font-family: monospace; white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${result.html.substring(0, 500)}${result.html.length > 500 ? '...' : ''}</div>`);
        } else {
          setClipResult('âš  No HTML in clipboard');
        }
      });

      // View history
      document.getElementById('clip-view-history')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardGetHistory(10);
        if (result.success && result.history.length > 0) {
          let output = `<strong>Clipboard History (${result.history.length} items):</strong><br><br>`;
          result.history.forEach((item, i) => {
            const time = new Date(item.timestamp).toLocaleTimeString();
            let content = '';
            if (item.type === 'text') {
              content = item.content.substring(0, 50) + (item.content.length > 50 ? '...' : '');
            } else if (item.type === 'image') {
              content = `Image ${item.size.width}x${item.size.height}`;
            } else {
              content = item.type.toUpperCase();
            }
            output += `${i + 1}. [${time}] ${item.type}: ${content}<br>`;
          });
          setClipResult(output);
        } else {
          setClipResult('No clipboard history yet');
        }
      });

      // Clear history
      document.getElementById('clip-clear-history')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardClearHistory();
        if (result.success) {
          setClipResult('âœ“ Clipboard history cleared');
        } else {
          setClipResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Toggle monitoring
      document.getElementById('clip-monitor-toggle')?.addEventListener('click', async () => {
        if (!clipMonitoring) {
          const result = await window.electronAPI.clipboardStartMonitoring(1000);
          if (result.success) {
            clipMonitoring = true;
            document.getElementById('clip-monitor-status').textContent = 'Stop Monitoring ðŸ”´';
            document.getElementById('clip-monitor-toggle').style.background = 'var(--accent-red)';
            setClipResult('âœ“ Clipboard monitoring started (auto-tracking changes)');
          }
        } else {
          const result = await window.electronAPI.clipboardStopMonitoring();
          if (result.success) {
            clipMonitoring = false;
            document.getElementById('clip-monitor-status').textContent = 'Start Monitoring';
            document.getElementById('clip-monitor-toggle').style.background = 'var(--bg-tertiary)';
            setClipResult('âœ“ Clipboard monitoring stopped');
          }
        }
      });

      // Get stats
      document.getElementById('clip-get-stats')?.addEventListener('click', async () => {
        const result = await window.electronAPI.clipboardGetStats();
        if (result.success) {
          const stats = result.stats;
          setClipResult(`<strong>Clipboard Statistics:</strong><br>` +
            `History Size: ${stats.historySize}/10<br>` +
            `Monitoring: ${stats.monitoring ? 'Active âœ“' : 'Inactive'}<br>` +
            `Current Formats: ${stats.currentFormats.join(', ')}<br>` +
            `Has Content: ${stats.hasContent ? 'Yes âœ“' : 'No'}`);
        } else {
          setClipResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Shell Integration handlers
      const shellResultContent = document.getElementById('shell-result-content');
      const shellSelectedFileDiv = document.getElementById('shell-selected-file');
      let selectedFilePath = null;

      function setShellResult(text, isError = false) {
        shellResultContent.innerHTML = text;
        shellResultContent.style.color = isError ? 'var(--accent-red)' : 'var(--text-secondary)';
      }

      // Open URL in browser
      document.getElementById('shell-open-url')?.addEventListener('click', async () => {
        const url = document.getElementById('shell-url').value;
        if (!url) {
          setShellResult('âš  Please enter a URL', true);
          return;
        }

        const result = await window.electronAPI.shellOpenExternal(url);
        if (result.success) {
          setShellResult(`âœ“ Opened in default browser: <strong>${result.url}</strong>`);
        } else {
          setShellResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Select file for shell operations
      document.getElementById('shell-select-file')?.addEventListener('click', async () => {
        const result = await window.electronAPI.openFileDialog({
          title: 'Select a file for shell operations',
          filters: [{ name: 'All Files', extensions: ['*'] }]
        });

        if (!result.canceled && result.filePaths.length > 0) {
          selectedFilePath = result.filePaths[0];
          shellSelectedFileDiv.innerHTML = `<strong>Selected:</strong> ${selectedFilePath}`;
          shellSelectedFileDiv.style.color = 'var(--text-primary)';
          setShellResult(`âœ“ File selected: ${selectedFilePath}`);
        } else {
          setShellResult('File selection canceled');
        }
      });

      // Open file with default application
      document.getElementById('shell-open-file')?.addEventListener('click', async () => {
        if (!selectedFilePath) {
          setShellResult('âš  Please select a file first', true);
          return;
        }

        const result = await window.electronAPI.shellOpenPath(selectedFilePath);
        if (result.success) {
          setShellResult(`âœ“ Opened with default application: <strong>${result.path}</strong>`);
        } else {
          setShellResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Show file in folder
      document.getElementById('shell-show-in-folder')?.addEventListener('click', async () => {
        if (!selectedFilePath) {
          setShellResult('âš  Please select a file first', true);
          return;
        }

        const result = await window.electronAPI.shellShowItemInFolder(selectedFilePath);
        if (result.success) {
          setShellResult(`âœ“ Revealed in file explorer: <strong>${result.path}</strong>`);
        } else {
          setShellResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Move file to trash
      document.getElementById('shell-move-to-trash')?.addEventListener('click', async () => {
        if (!selectedFilePath) {
          setShellResult('âš  Please select a file first', true);
          return;
        }

        // Confirm before trashing
        const confirmResult = await window.electronAPI.showMessageBox({
          type: 'warning',
          title: 'Move to Trash',
          message: 'Are you sure you want to move this file to trash?',
          detail: selectedFilePath,
          buttons: ['Move to Trash', 'Cancel'],
          defaultId: 1
        });

        if (confirmResult.response === 0) {
          const result = await window.electronAPI.shellMoveItemToTrash(selectedFilePath);
          if (result.success) {
            setShellResult(`âœ“ Moved to trash: <strong>${result.path}</strong>`);
            selectedFilePath = null;
            shellSelectedFileDiv.innerHTML = 'File was moved to trash. Select another file.';
            shellSelectedFileDiv.style.color = 'var(--text-secondary)';
          } else {
            setShellResult(`âœ— Error: ${result.error}`, true);
          }
        } else {
          setShellResult('Trash operation canceled');
        }
      });

      // Play system beep
      document.getElementById('shell-beep')?.addEventListener('click', async () => {
        const result = await window.electronAPI.shellBeep();
        if (result.success) {
          setShellResult('âœ“ System beep played! ðŸ””');
        } else {
          setShellResult(`âœ— Error: ${result.error}`, true);
        }
      });

      // Test protocol handler
      document.getElementById('shell-test-protocol')?.addEventListener('click', async () => {
        const testUrl = 'electronshowcase://test/demo?source=ui&timestamp=' + Date.now();

        // Create a temporary HTML file to trigger the protocol
        const htmlContent = `
<!DOCTYPE html>
<html>
<head><title>Protocol Test</title></head>
<body>
<h1>Protocol Handler Test</h1>
<p>Click the link below to test the custom protocol handler:</p>
<p><a href="${testUrl}">electronshowcase://test/demo</a></p>
<script>
  // Auto-click after 1 second
  setTimeout(() => {
    document.querySelector('a').click();
  }, 1000);
<\/script>
</body>
</html>`;

        const saveResult = await window.electronAPI.saveFileDialog({
          title: 'Save Protocol Test HTML',
          defaultPath: 'protocol-test.html',
          filters: [{ name: 'HTML Files', extensions: ['html'] }]
        });

        if (!saveResult.canceled && saveResult.filePath) {
          await window.electronAPI.writeFile(saveResult.filePath, htmlContent);

          // Open the HTML file in default browser
          const openResult = await window.electronAPI.shellOpenPath(saveResult.filePath);

          if (openResult.success) {
            setShellResult(`âœ“ Protocol test page opened!<br>` +
              `When you click the link, this app will be launched with:<br>` +
              `<div style="margin-top: 8px; padding: 8px; background: var(--bg-primary); border-radius: 4px; font-family: monospace;">${testUrl}</div>`);
          }
        } else {
          setShellResult('Protocol test canceled');
        }
      });

      // Listen for protocol URL events
      window.electronAPI.on('protocol:url-received', (data) => {
        console.log('Protocol URL received:', data);
        setShellResult(`âœ“ Protocol URL Received!<br>` +
          `<strong>Action:</strong> ${data.action}<br>` +
          `<strong>Params:</strong> ${data.params}<br>` +
          `<strong>Full URL:</strong> <div style="margin-top: 8px; padding: 8px; background: var(--bg-primary); border-radius: 4px; font-family: monospace;">${data.url}</div>`);
      });

      // Global Shortcuts handlers
      const shortcutsResultContent = document.getElementById('shortcuts-result-content');
      const shortcutsList = document.getElementById('shortcuts-list');
      const shortcutsRecorder = document.getElementById('shortcuts-recorder');
      const shortcutsRecorderStatus = document.getElementById('shortcuts-recorder-status');
      const shortcutsRecordBtn = document.getElementById('shortcuts-record-btn');
      let isRecording = false;
      let recordedKeys = [];

      function setShortcutsResult(text, isError = false) {
        if (!shortcutsResultContent) return;
        shortcutsResultContent.innerHTML = text;
        shortcutsResultContent.style.color = isError ? 'var(--accent-red)' : 'var(--text-secondary)';
      }

      // Load and display all shortcuts
      async function loadShortcuts() {
        try {
          const result = await window.electronAPI.shortcutsGetAll();
          if (result.success) {
            displayShortcuts(result.shortcuts);
            await updateShortcutsStats();
          } else {
            setShortcutsResult(`âœ— Error loading shortcuts: ${result.error}`, true);
          }
        } catch (error) {
          setShortcutsResult(`âœ— Error: ${error.message}`, true);
        }
      }

      // Display shortcuts in the list
      function displayShortcuts(shortcuts) {
        if (shortcuts.length === 0) {
          shortcutsList.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: var(--space-4);">No shortcuts registered</div>';
          return;
        }

        shortcutsList.innerHTML = '';

        shortcuts.forEach(shortcut => {
          const item = document.createElement('div');
          item.style.cssText = 'display: grid; grid-template-columns: auto 1fr auto auto auto; gap: 12px; align-items: center; padding: 8px; background: var(--bg-primary); border-radius: 4px; margin-bottom: 8px;';

          // Status indicator
          const status = document.createElement('div');
          status.style.cssText = `width: 8px; height: 8px; border-radius: 50%; background: ${shortcut.enabled ? 'var(--accent-green)' : 'var(--text-tertiary)'};`;
          status.title = shortcut.enabled ? 'Enabled' : 'Disabled';
          item.appendChild(status);

          // Shortcut info
          const info = document.createElement('div');
          info.innerHTML = `
            <div style="color: var(--text-primary); font-weight: 500; margin-bottom: 2px;">${shortcut.description}</div>
            <div style="color: var(--text-secondary); font-size: var(--font-size-xs); font-family: monospace;">${shortcut.accelerator} â†’ ${shortcut.action}</div>
          `;
          item.appendChild(info);

          // Toggle button
          const toggleBtn = document.createElement('button');
          toggleBtn.className = 'btn';
          toggleBtn.textContent = shortcut.enabled ? 'Disable' : 'Enable';
          toggleBtn.style.cssText = `padding: 4px 12px; font-size: var(--font-size-xs); background: ${shortcut.enabled ? 'var(--accent-yellow)' : 'var(--accent-green)'};`;
          toggleBtn.onclick = async () => {
            const result = await window.electronAPI.shortcutsToggle(shortcut.id);
            if (result.success) {
              setShortcutsResult(`âœ“ Shortcut ${result.enabled ? 'enabled' : 'disabled'}: ${shortcut.description}`);
              await loadShortcuts();
            } else {
              setShortcutsResult(`âœ— Error: ${result.error}`, true);
            }
          };
          item.appendChild(toggleBtn);

          // Edit button
          const editBtn = document.createElement('button');
          editBtn.className = 'btn';
          editBtn.textContent = 'Edit';
          editBtn.style.cssText = 'padding: 4px 12px; font-size: var(--font-size-xs); background: var(--accent-blue);';
          editBtn.onclick = async () => {
            const newAccelerator = prompt(`Edit shortcut for: ${shortcut.description}\n\nCurrent: ${shortcut.accelerator}\n\nEnter new shortcut:`, shortcut.accelerator);
            if (newAccelerator && newAccelerator !== shortcut.accelerator) {
              // Check availability
              const checkResult = await window.electronAPI.shortcutsCheckAvailability(newAccelerator);
              if (!checkResult.available) {
                alert(`Cannot use "${newAccelerator}": ${checkResult.message}`);
                return;
              }

              // Update shortcut
              const result = await window.electronAPI.shortcutsUpdate(shortcut.id, newAccelerator);
              if (result.success) {
                setShortcutsResult(`âœ“ Shortcut updated: ${shortcut.accelerator} â†’ ${newAccelerator}`);
                await loadShortcuts();
              } else {
                setShortcutsResult(`âœ— Error updating: ${result.error}`, true);
              }
            }
          };
          item.appendChild(editBtn);

          // Delete button
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'btn';
          deleteBtn.textContent = 'Delete';
          deleteBtn.style.cssText = 'padding: 4px 12px; font-size: var(--font-size-xs); background: var(--accent-red);';
          deleteBtn.onclick = async () => {
            if (confirm(`Delete shortcut: ${shortcut.description}?`)) {
              const result = await window.electronAPI.shortcutsUnregister(shortcut.id);
              if (result.success) {
                setShortcutsResult(`âœ“ Shortcut deleted: ${shortcut.description}`);
                await loadShortcuts();
              } else {
                setShortcutsResult(`âœ— Error deleting: ${result.error}`, true);
              }
            }
          };
          item.appendChild(deleteBtn);

          shortcutsList.appendChild(item);
        });
      }

      // Update statistics
      async function updateShortcutsStats() {
        try {
          const result = await window.electronAPI.shortcutsGetStats();
          if (result.success) {
            document.getElementById('stats-shortcuts-total').textContent = result.stats.totalShortcuts;
            document.getElementById('stats-shortcuts-enabled').textContent = result.stats.enabledShortcuts;
            document.getElementById('stats-shortcuts-disabled').textContent = result.stats.disabledShortcuts;
            document.getElementById('stats-shortcuts-triggered').textContent = result.stats.totalTriggered;
          }
        } catch (error) {
          console.error('Error updating shortcuts stats:', error);
        }
      }

      // Shortcut recorder
      function startRecording() {
        isRecording = true;
        recordedKeys = [];
        shortcutsRecorder.value = '';
        shortcutsRecorder.style.borderColor = 'var(--accent-blue)';
        shortcutsRecorder.style.background = 'var(--bg-secondary)';
        shortcutsRecorderStatus.textContent = 'Recording... Press your desired shortcut combination';
        shortcutsRecorderStatus.style.color = 'var(--accent-blue)';
        shortcutsRecordBtn.textContent = 'Stop Recording';
        shortcutsRecordBtn.style.background = 'var(--accent-red)';
        shortcutsRecorder.focus();
      }

      function stopRecording() {
        isRecording = false;
        shortcutsRecorder.style.borderColor = 'var(--border)';
        shortcutsRecorder.style.background = 'var(--bg-tertiary)';
        shortcutsRecorderStatus.textContent = '';
        shortcutsRecordBtn.textContent = 'Start Recording';
        shortcutsRecordBtn.style.background = 'var(--accent-blue)';
      }

      // Handle keyboard events for recording
      document.addEventListener('keydown', (e) => {
        if (!isRecording) return;

        e.preventDefault();

        const modifiers = [];
        if (e.ctrlKey || e.metaKey) modifiers.push(e.metaKey && window.electronAPI.platform === 'darwin' ? 'Command' : 'Control');
        if (e.altKey) modifiers.push('Alt');
        if (e.shiftKey) modifiers.push('Shift');

        // Get the actual key
        let key = e.key;
        if (key === 'Control' || key === 'Alt' || key === 'Shift' || key === 'Meta') {
          // Just modifiers, don't record yet
          return;
        }

        // Format the key name
        if (key.length === 1) {
          key = key.toUpperCase();
        } else if (key.startsWith('Arrow')) {
          key = key.replace('Arrow', '');
        }

        // Build accelerator
        const accelerator = modifiers.concat(key).join('+');
        shortcutsRecorder.value = accelerator;

        // Check availability
        window.electronAPI.shortcutsCheckAvailability(accelerator).then(result => {
          if (result.available) {
            shortcutsRecorderStatus.textContent = `âœ“ "${accelerator}" is available!`;
            shortcutsRecorderStatus.style.color = 'var(--accent-green)';
          } else {
            shortcutsRecorderStatus.textContent = `âœ— ${result.message}`;
            shortcutsRecorderStatus.style.color = 'var(--accent-red)';
          }
        });
      });

      // Refresh button
      document.getElementById('shortcuts-refresh')?.addEventListener('click', async () => {
        await loadShortcuts();
        setShortcutsResult('âœ“ Shortcuts list refreshed');
      });

      // Record button
      shortcutsRecordBtn?.addEventListener('click', () => {
        if (isRecording) {
          const accelerator = shortcutsRecorder.value;
          if (accelerator) {
            // Prompt for details
            const description = prompt(`Create shortcut for: ${accelerator}\n\nEnter description:`, 'Custom action');
            if (description) {
              const action = prompt('Enter action name (e.g., custom-action):', 'custom-action');
              if (action) {
                const id = `custom-${Date.now()}`;
                window.electronAPI.shortcutsRegister(id, accelerator, action, description).then(result => {
                  if (result.success) {
                    setShortcutsResult(`âœ“ Shortcut registered: ${accelerator} â†’ ${action}`);
                    loadShortcuts();
                  } else {
                    setShortcutsResult(`âœ— Error: ${result.error}`, true);
                  }
                });
              }
            }
          }
          stopRecording();
        } else {
          startRecording();
        }
      });

      // Test buttons
      document.getElementById('shortcuts-test-window')?.addEventListener('click', () => {
        setShortcutsResult('Press Ctrl+Alt+E (or Cmd+Alt+E on Mac) to test show/hide window functionality!');
      });

      document.getElementById('shortcuts-test-clipboard')?.addEventListener('click', () => {
        setShortcutsResult('Copy some text, then press Ctrl+Alt+C (or Cmd+Alt+C on Mac) to capture clipboard!');
      });

      // Export shortcuts
      document.getElementById('shortcuts-export')?.addEventListener('click', async () => {
        const result = await window.electronAPI.shortcutsExport();
        if (result.success) {
          const jsonString = JSON.stringify(result.config, null, 2);

          // Save to file
          const saveResult = await window.electronAPI.saveFileDialog({
            title: 'Export Shortcuts',
            defaultPath: `shortcuts-export-${Date.now()}.json`,
            filters: [{ name: 'JSON Files', extensions: ['json'] }]
          });

          if (!saveResult.canceled && saveResult.filePath) {
            await window.electronAPI.writeFile(saveResult.filePath, jsonString);
            setShortcutsResult(`âœ“ Shortcuts exported to: ${saveResult.filePath}`);
          } else {
            setShortcutsResult('Export canceled');
          }
        } else {
          setShortcutsResult(`âœ— Error exporting: ${result.error}`, true);
        }
      });

      // Import shortcuts
      document.getElementById('shortcuts-import')?.addEventListener('click', async () => {
        const fileResult = await window.electronAPI.openFileDialog({
          title: 'Import Shortcuts',
          filters: [{ name: 'JSON Files', extensions: ['json'] }]
        });

        if (!fileResult.canceled && fileResult.filePaths.length > 0) {
          const readResult = await window.electronAPI.readFile(fileResult.filePaths[0]);

          if (readResult.success) {
            try {
              const config = JSON.parse(readResult.content);
              const importResult = await window.electronAPI.shortcutsImport(config);

              if (importResult.success) {
                setShortcutsResult(`âœ“ Imported ${importResult.count} shortcuts from: ${fileResult.filePaths[0]}`);
                await loadShortcuts();
              } else {
                setShortcutsResult(`âœ— Error importing: ${importResult.error}`, true);
              }
            } catch (error) {
              setShortcutsResult(`âœ— Invalid JSON file: ${error.message}`, true);
            }
          } else {
            setShortcutsResult(`âœ— Error reading file: ${readResult.error}`, true);
          }
        } else {
          setShortcutsResult('Import canceled');
        }
      });

      // Reset to defaults
      document.getElementById('shortcuts-reset')?.addEventListener('click', async () => {
        if (!confirm('Reset all shortcuts to defaults? This will overwrite your current shortcuts.')) {
          return;
        }

        const result = await window.electronAPI.shortcutsResetToDefaults();
        if (result.success) {
          setShortcutsResult(`âœ“ Shortcuts reset to defaults (${result.shortcuts.length} shortcuts)`);
          await loadShortcuts();
        } else {
          setShortcutsResult(`âœ— Error resetting: ${result.error}`, true);
        }
      });

      // Disable all shortcuts
      document.getElementById('shortcuts-disable-all')?.addEventListener('click', async () => {
        const allResult = await window.electronAPI.shortcutsGetAll();
        if (allResult.success) {
          let disabled = 0;
          for (const shortcut of allResult.shortcuts) {
            if (shortcut.enabled) {
              const result = await window.electronAPI.shortcutsDisable(shortcut.id);
              if (result.success) disabled++;
            }
          }
          setShortcutsResult(`âœ“ Disabled ${disabled} shortcut(s)`);
          await loadShortcuts();
        }
      });

      // Listen for shortcut triggers
      window.electronAPI.on('shortcut:triggered', (data) => {
        console.log('Shortcut triggered:', data);
        setShortcutsResult(`âœ“ Shortcut Triggered!<br>` +
          `<strong>Action:</strong> ${data.action}<br>` +
          `<strong>Accelerator:</strong> ${data.accelerator}<br>` +
          `<strong>Time:</strong> ${new Date(data.timestamp).toLocaleTimeString()}`);
        updateShortcutsStats();
      });

      // Initial load of shortcuts
      loadShortcuts();

      // Refresh shortcuts stats periodically
      setInterval(updateShortcutsStats, 10000);
    })();
  </script>

  <!-- System Information Dashboard -->
  <script src="./renderer-systeminfo.js"></script>
</body>
</html>
